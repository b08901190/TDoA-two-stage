# -*- coding: utf-8 -*-
"""demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yKYyBTUNHyEO0Bf5Wzq5hBbuK8BL2XDb
"""

import numpy as np
from scipy import optimize
import sys, collections, time
from scipy.optimize import lsq_linear, root, minimize
import random
import matplotlib.pyplot as plt
from tqdm import tqdm, trange
import numpy.matlib 
from itertools import product
from itertools import combinations
from collections import Counter
import numpy as np
import matplotlib.pyplot as plt 
from mpl_toolkits.mplot3d import Axes3D
import heapq

def lsq_method(distances_to_anchors, anchor_positions): ##x 和 y 軸是準的 ，z軸在共平面時又大誤差
    distances_to_anchors, anchor_positions = np.array(distances_to_anchors), np.array(anchor_positions)
    if not np.all(distances_to_anchors):
        raise ValueError('Bad uwb connection. distances_to_anchors must never be zero. ' + str(distances_to_anchors))
    anchor_offset = anchor_positions[0]
    anchor_positions = anchor_positions[1:] - anchor_offset
    K = np.sum(np.square(anchor_positions), axis=1)   #ax=1 列加
    squared_distances_to_anchors = np.square(distances_to_anchors)
    squared_distances_to_anchors = (squared_distances_to_anchors - squared_distances_to_anchors[0])[1:]
    b = (K - squared_distances_to_anchors) / 2.
    res = lsq_linear(anchor_positions, b, lsmr_tol='auto', verbose=0)
    return res.x + anchor_offset

def costfun_method(distances_to_anchors, anchor_positions): ##找較準確的z 
    distances_to_anchors, anchor_positions = np.array(distances_to_anchors), np.array(anchor_positions)
    tag_pos = lsq_method(distances_to_anchors, anchor_positions)
    anc_z_ls_mean = np.mean(np.array([i[2] for i in anchor_positions]) )  
    new_z = (np.array([i[2] for i in anchor_positions]) - anc_z_ls_mean).reshape(5, 1)
    new_anc_pos = np.concatenate((np.delete(anchor_positions, 2, axis = 1), new_z ), axis=1)
    new_disto_anc = np.sqrt(abs(distances_to_anchors[:]**2 - (tag_pos[0] - new_anc_pos[:,0])**2 - (tag_pos[1] - new_anc_pos[:,1])**2))
    new_z = new_z.reshape(5,)

    a = (np.sum(new_disto_anc[:]**2) - 3*np.sum(new_z[:]**2))/len(anchor_positions)
    b = (np.sum((new_disto_anc[:]**2) * (new_z[:])) - np.sum(new_z[:]**3))/len(anchor_positions)
    cost = lambda z: np.sum(((z - new_z[:])**4 - 2*(((new_disto_anc[:])*(z - new_z[:]))**2 ) + new_disto_anc[:]**4))/len(anchor_positions) 

    function = lambda z: z**3 - a*z + b
    derivative = lambda z: 3*z**2 - a

    def newton(function, derivative, x0, tolerance, number_of_max_iterations=50):
        x1, k = 0, 1
        if (abs(x0-x1)<= tolerance and abs((x0-x1)/x0)<= tolerance):  return x0
        while(k <= number_of_max_iterations):
            x1 = x0 - (function(x0)/derivative(x0))
            if (abs(x0-x1)<= tolerance and abs((x0-x1)/x0)<= tolerance): return x1
            x0 = x1
            k = k + 1
            if (k > number_of_max_iterations): pass
                # print("ERROR: Exceeded max number of iterations")
        return x1 

    
    ranges = (slice(0, 100, 0.05), )
    resbrute = optimize.brute(cost, ranges, full_output = True, finish = optimize.fmin)
    new_tag_pos = np.concatenate((np.delete(np.array(tag_pos), 2), resbrute[0] + anc_z_ls_mean))
    
    return np.around(new_tag_pos, 4)

def TDoA(distances_diffrences, anchor_num, anchor_positions):
    
    A = [0]*anchor_num
    B = [0]*anchor_num
    C = [0]*anchor_num
    D = [0]*anchor_num
    
    x = [0]*anchor_num
    y = [0]*anchor_num
    z = [0]*anchor_num
    
    for i in range(anchor_num):
        x[i] = anchor_positions[i][0]
        y[i] = anchor_positions[i][1]
        z[i] = anchor_positions[i][2]
     
    for i in range(2,anchor_num):
        A[i] = ( 1/(distances_diffrences[i]) ) * (-2*x[0]+2*x[i]) - ( 1/(distances_diffrences[1]) ) * (-2*x[0]+2*x[1])
        B[i] = ( 1/(distances_diffrences[i]) ) * (-2*y[0]+2*y[i]) - ( 1/(distances_diffrences[1]) ) * (-2*y[0]+2*y[1])
        C[i] = ( 1/(distances_diffrences[i]) ) * (-2*z[0]+2*z[i]) - ( 1/(distances_diffrences[1]) ) * (-2*z[0]+2*z[1])
        S1 =  x[0]**2 + y[0]**2+ z[0]**2 - x[i]**2 - y[i]**2 - z[i]**2
        S2 =  x[0]**2 + y[0]**2+ z[0]**2 - x[1]**2 - y[1]**2 - z[1]**2
        D[i] = distances_diffrences[i] - distances_diffrences[1] + ( 1/distances_diffrences[i] )*S1 - ( 1/(distances_diffrences[1]) )*S2


    M = [[0]*3]*(anchor_num-2)
    N = [0]*(anchor_num-2)

    for i in range(anchor_num-2):
        M[i] = [A[i+2],B[i+2],C[i+2]]
        N[i] =  D[i+2]

    if anchor_num ==5 :
        Minv = np.linalg.inv(M)
    else :
        Minv = np.linalg.pinv(M)
    
    Minv_M = np.dot(Minv,M)
#     M_trans = np.transpose(M)
    
#     Minv2 = dot( np.linalg.inv( dot(M_trans, M) ) ,  M_trans )

    T = np.dot(Minv,N)
    
    
    x = float(-1*T[0]) 
    y = float(-1*T[1]) 
    z = float(-1*T[2]) 
    location = [x , y, z]

    return location,M,N,Minv,Minv_M

def select_real_location() :
        a,b = -1,1
        x = 10 * random.uniform(a,b)
        y = 10 * random.uniform(a,b)
        z = 10 * random.uniform(a,b)
        return [x,y,z]

def calculate_distances(anchor,anchor_num,real_position):        
        distances = [0]*anchor_num
        for i in range(anchor_num):
            distance_square = 0
            for j in range(3):
                distance_square += (anchor[i][j]-real_position[j])**2
            distances[i] = distance_square **(1/2)
        return distances
def calculate_distances_diffrences(distances_to_anchors,anchor_num):
    distances_diffrences = [0]*anchor_num
    for i in range(anchor_num):
        distances_diffrences[i] = distances_to_anchors[i] - distances_to_anchors[0]
    return distances_diffrences
def generate_noises(anchor_num,size,noise_scale):
    noises = [0]*anchor_num
    for i in range (anchor_num):
        noises[i] = np.random.normal(loc=0, scale=noise_scale, size=size)
    return noises

# task 可出現的位置：for every 1m
all_task_positions_1m = []
for k in range(11):
    z = k
    for i in range(1,20):
        x = i*0.5
        for j in range(1,20):
            y = j*0.5

            all_task_positions_1m.append([x,y,z])
print(len(all_task_positions_1m))

# task 可出現的位置： for every 0.1m
all_task_positions_01m = []
for i in range(1,100):
    x = i*0.1
    for j in range(1,100):
        y = j*0.1
        for k in range(1,100):
            z = k*0.1
            all_task_positions_01m.append([x,y,z])
print(len(all_task_positions_01m))

# method 分 ToA and TDoA
# position_type 分 only_one :只測試 給定的position那一點
#                  1m : all_task_positions_1m 中的每一點皆測試一次
#                  01m : all_task_positions_01m 中的每一點皆測試一次
#                  select : 測試 select_real_location() 這個 function return 的 位置

def test (anchor_num ,anchor ,size ,method ,noise_scale,position_type, position=[0,0,0], with_noises=True):

#     progress = tqdm(total=size) 

    if method == "ToA":  
        progress = tqdm(total=size) 
    
    without_noise_locations = [0]*size
    locations = [0]*size
    real_positions = [0]*size
    all_noisy_distances_diffrences = [0]*size
    
    Ms = [0]*size
    Ns = [0]*size
    Minvs= [0]*size
    Minv_M = [0]*size
    
    mini_error_real_locations = []
    error_real_locations = []
    large_error_distance = []
    error_distance = [0]*size

    mini_error_num = 0
    error_num = 0
    average_error = 0
    
    error_x = [0]*size
    error_y = [0]*size
    error_z = [0]*size

    noisy_distances = [0]*anchor_num
    noisy_distances_diffrences = [0]*anchor_num
    noises = generate_noises(anchor_num,size,noise_scale)
    
    
    for k in range(size):

#         progress.update(1)
        
        if position_type == "only_one":
            [x,y,z] = position
            real_position = [x,y,z]
        
        if position_type == "select":
            [x,y,z] = select_real_location()
            real_position = [x,y,z]
        
        if position_type == "01m":
#             size = 1030301
            real_position = all_task_positions_01m[k]
        
        if position_type == "1m":
#             size = 1331
            real_position = all_task_positions_1m[k]
         
        real_positions[k]=real_position
    
        distances_to_anchors = calculate_distances(anchor,anchor_num,real_position)
        
        distances_diffrences = calculate_distances_diffrences(distances_to_anchors,anchor_num)
            
        anchor_positions = anchor

        
        if method == "ToA":
            progress.update(1)
            for i in range(anchor_num):
                noisy_distances[i] = distances_to_anchors[i] + noises[i][k]

            locations[k] = costfun_method(noisy_distances, anchor_positions)
        
        if method == "TDoA":
            
            noisy_distances_diffrences = distances_diffrences
            
            for i in range(anchor_num):
                if with_noises == True:
                    noisy_distances_diffrences[i] = distances_diffrences[i] + noises[i][k]
            
            all_noisy_distances_diffrences[k] = noisy_distances_diffrences
            locations[k],Ms[k],Ns[k],Minvs[k],Minv_M[k] = TDoA(noisy_distances_diffrences, anchor_num, anchor_positions)

        error_x[k] = (locations[k][0]-real_position[0])
        error_y[k] = (locations[k][1]-real_position[1])
        error_z[k] = (locations[k][2]-real_position[2])
        error_distance[k] = ( error_x[k]**2 + error_y[k]**2 + error_z[k]**2 )**(1/2)
        
        if error_distance[k] >= 0.3: #誤差大於30cm
            mini_error_num += 1
            error_num += 1
            error_real_locations.append(real_position)
            large_error_distance.append(error_distance[k])
        elif error_distance[k] >= 0.1: #誤差大於10cm
            mini_error_num += 1
            mini_error_real_locations.append(real_position)
        average_error += error_distance[k]/size
    
    return {"average_error":average_error , "error_distance":error_distance , "error_x":error_x , "error_y":error_y , "error_z":error_z , 
            "error_num":error_num ,"mini_error_num":mini_error_num,
            "mini_error_real_locations":mini_error_real_locations,"error_real_locations":error_real_locations,
           "large_error_distance":large_error_distance,"Ms":Ms,"Ns":Ns,"calculate_positions":locations,"Minvs":Minvs,
            "Minv_M":Minv_M,"real_positions":real_positions,"all_noisy_distances_diffrences":all_noisy_distances_diffrences}

def test_performance_of_diffrenct_locations(anchor_num,anchor,test_positions,noise_scale,test_time_in_one_position,with_noises=True,method = "TDoA"):
    a = tqdm(total = len(test_positions))
    
    positions_num = len(test_positions)
    
    anchor_num = anchor_num
    anchor = anchor
    
    result = [0]*positions_num
    
    average_error = [0]*positions_num
    
    error_x = [0]*positions_num
    error_y= [0]*positions_num
    error_z = [0]*positions_num
    
    Ms=[0]*positions_num
    Minvs = [0]*positions_num
    Ns = [0]*positions_num
    Minv_M = [0]*positions_num
    
    calculate_positions =[0]*positions_num 
    for i in range(positions_num):
        a.update(1)
        result[i] = test(anchor_num=anchor_num , anchor=anchor , size=test_time_in_one_position, method = method ,noise_scale=noise_scale, position_type = "only_one",position=test_positions[i],with_noises=with_noises)
        
        average_error[i] = result[i]["average_error"]

        error_x[i]=result[i]["error_x"]         
        error_y[i]=result[i]["error_y"]         
        error_z[i]=result[i]["error_z"] 
        
        Ms[i] = result[i]["Ms"]
        Minvs[i]=result[i]["Minvs"]
        Ns[i]=result[i]["Ns"]
        Minv_M[i]=result[i]["Minv_M"]
        
        calculate_positions[i] = result[i]["calculate_positions"]##算出來的位置
    
    color=[0]*positions_num
    color2=[0]*positions_num
    color3=[0]*positions_num
    for i in range(positions_num):
        if abs(result[i]["average_error"])<noise_scale:
            color[i]="blue"
        elif abs(result[i]["average_error"])>noise_scale and abs(result[i]["average_error"])<3*noise_scale:
            color[i]="green"
        elif abs(result[i]["average_error"])>3*noise_scale and abs(result[i]["average_error"])<10*noise_scale:
            color[i]="yellow"
        elif abs(result[i]["average_error"])>10*noise_scale and abs(result[i]["average_error"])<50*noise_scale:
            color[i]="orange"
        elif abs(result[i]["average_error"])>50*noise_scale:
            color[i]="red"

    for i in range(positions_num):
        if abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])<noise_scale:
            color2[i]="blue"
        elif abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])>noise_scale and abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])<3*noise_scale:
            color2[i]="green"
        elif abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])>3*noise_scale and abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])<10*noise_scale:
            color2[i]="yellow"
        elif abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])>10*noise_scale and abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])<50*noise_scale:
            color2[i]="orange"
        elif abs(result[i]["error_x"][0])+abs(result[i]["error_y"][0])>50*noise_scale:
            color2[i]="red"
    for i in range(positions_num):
        if abs(result[i]["error_x"][0])<noise_scale:
            color3[i]="blue"
        elif abs(result[i]["error_x"][0])>noise_scale and abs(result[i]["error_x"][0])<3*noise_scale:
            color3[i]="green"
        elif abs(result[i]["error_x"][0])>3*noise_scale and abs(result[i]["error_x"][0])<10*noise_scale:
            color3[i]="yellow"
        elif abs(result[i]["error_x"][0])>10*noise_scale and abs(result[i]["error_x"][0])<50*noise_scale:
            color3[i]="orange"
        elif abs(result[i]["error_x"][0])>50*noise_scale:
            color3[i]="red"
    
    return color,color2,color3,average_error

# 試試看 test_performance_of_diffrenct_locations() 可不可以work
anchor_num = 5
anchor =[[0, 0, 0], [10, 0, 0], [0, 10, 0], [10, 10, 0.0000000000001], [5, 5, 0]]
test_positions = all_task_positions_1m
noise_scale = 0.1
test_time_in_one_position = 1

color,color2,color3,average_error = test_performance_of_diffrenct_locations(anchor_num,anchor,test_positions,noise_scale,test_time_in_one_position,with_noises=True,method = "TDoA")

all = 0
for i in range(len(average_error)):
    all += average_error[i]
all = all/len(average_error)
print(all)

ax = plt.subplot(111,projection="3d")
test_positions = all_task_positions_1m
for i in range(len(test_positions)):
    [x,y,z] = test_positions[i]
    if color2[i]=="yellow":
        ax.scatter(x,y,z,c=color2[i])
plt.show

print(color2.count("red"))
print(color2.count("orange"))
print(color2.count("yellow"))
print(color2.count("green"))
print(color2.count("blue"))

anchor_num = 5
anchor =[[0, 0, 0], [10, 0, 10], [0, 10, 10], [5, 5, 10], [10, 10, 0]]
noise_scale = 0.1
size = len(all_task_positions_1m)
method = "TDoA"
position_type = "1m"
result = test(anchor_num ,anchor ,size ,method ,noise_scale,position_type,with_noises=True)

all = [[]]*11
diffrent_height_error_wo_z = [[]]*11
total_average_error_wo_z = 0
for i in range(11):
    x = 0
    for j in range(0+361*i,361+361*i):
        x += ( abs(result["error_x"][j])**2 + abs(result["error_y"][j])**2 ) ** 0.5
    all[i] = x
for i in range(11):
    diffrent_height_error_wo_z[i] = all[i]/361
for i in range(size):
        x = ( abs(result["error_x"][i])**2 + abs(result["error_y"][i])**2 ) ** 0.5
        total_average_error_wo_z += x/size
print(diffrent_height_error_wo_z )
print(total_average_error_wo_z)

diffrent_x_error_wo_z = [[]]*11
for i in range(11):
    p = 0
    q = 0
    x = 10+0.5*i
    for j in range(size):
        if result["real_positions"][j][0] == x :
          p += ( abs(result["error_x"][j])**2 + abs(result["error_y"][j])**2 ) ** 0.5 
          q += 1
    diffrent_x_error_wo_z[i] = p/q
print(diffrent_x_error_wo_z)

# a = 0
# for i in range(size):
#   if result["error_x"][i]>10 or result["error_y"][i]>10 :
#      print(result["all_noisy_distances_diffrences"][i])
# color2 = [0]*size
# for i in range(size):
#         if abs(result["error_x"][i])+abs(result["error_y"][i])<noise_scale:
#             color2[i]="blue"
#         elif abs(result["error_x"][i])+abs(result["error_y"][i])>noise_scale and abs(result["error_x"][i])+abs(result["error_y"][i])<3*noise_scale:
#             color2[i]="green"
#         elif abs(result["error_x"][i])+abs(result["error_y"][i])>3*noise_scale and abs(result["error_x"][i])+abs(result["error_y"][i])<10*noise_scale:
#             color2[i]="yellow"
#         elif abs(result["error_x"][i])+abs(result["error_y"][i])>10*noise_scale and abs(result["error_x"][i])+abs(result["error_y"][i])<50*noise_scale:
#             color2[i]="orange"
#         elif abs(result["error_x"][i])+abs(result["error_y"][i])>50*noise_scale:
#             color2[i]="red"

#算準一點的z
anchor_num = 5
anchor =[[0, 0, 0], [10, 0, 10], [0, 10, 10], [5, 5, 10], [10, 10, 0]]
size = len(all_task_positions_1m)
new_cal_positions = []
a = tqdm(total = size)
for i in range(size):
  real_position = result["real_positions"][i]
  calculate_position = result["calculate_positions"][i]
  distances = calculate_distances(anchor,anchor_num,real_position)      
  E = calculate_distances_diffrences(distances,anchor_num)
  A = anchor_num*[0]
  B = anchor_num*[0]
  C = anchor_num*[0]
  D = anchor_num*[0]
  for i in range(len(A)):
      A[i] = (anchor[i][0]-calculate_position[0])**2+(anchor[i][1]-calculate_position[1])**2
      B[i] = (anchor[0][0]-calculate_position[0])**2+(anchor[0][1]-calculate_position[1])**2
      C[i] = anchor[i][2]
      D[i] = anchor[0][2]
  cost = lambda z: abs(E[4]-((A[4]+(C[4]-z)**2)**0.5)+((B[4]+(D[4]-z)**2)**0.5)) + abs(E[1]-((A[1]+(C[1]-z)**2)**0.5)+((B[1]+(D[1]-z)**2)**0.5)) + abs(E[2]-((A[2]+(C[2]-z)**2)**0.5)+((B[2]+(D[2]-z)**2)**0.5))+abs(E[3]-((A[3]+(C[3]-z)**2)**0.5)+((B[3]+(D[3]-z)**2)**0.5))
  ranges = (slice(0, 10, 0.01), )
  resbrute = optimize.brute(cost, ranges, full_output = True, finish = optimize.fmin)
  if resbrute[0] > 10 or resbrute[0] < 0 :
      resbrute = optimize.brute(cost, ranges, full_output = True, finish = None)
  new_cal_position = [calculate_position[0],calculate_position[1],float(resbrute[0])]
  new_cal_positions.append(new_cal_position)
  a.update(1)
for i in range(len(new_cal_positions)):
    for j in range(3):
        if np.isnan(new_cal_positions[i][j]):
           new_cal_positions[i][j] = 0   
print(len(new_cal_positions))
# def function(z,A,B,C,D):
#     fun = 0
#     for i in range(len(A)):
#         fun += (C[i]-z)/(((C[i]-z)**2+A[i])**0.5) - (D[i]-z)/(((D[i]-z)**2+B[i])**0.5)
#     return fun
# def diff(z,A,B,C,D):
#     dif = 0
#     for i in range(len(A)):
#         dif -= ( A[i]*(((D[i]-z)**2+B[i])**1.5)-B[i]*(((C[i]-z)**2+A[i])**1.5) ) / ( (((C[i]-z)**2+A[i])**1.5) + (((D[i]-z)**2+B[i])**1.5) )
#     return dif
# z = 1000
# for i in range(1000):
#     z = z - function(z,A,B,C,D)/diff(z,A,B,C,D)
# print("z",z)

error = [0]*len(new_cal_positions)
for i in range(len(new_cal_positions)):
    error[i] = (new_cal_positions[i][0]-result["real_positions"][i][0])**2
    error[i] += (new_cal_positions[i][1]-result["real_positions"][i][1])**2
    error[i] += (new_cal_positions[i][2]-result["real_positions"][i][2])**2
    error[i] = error[i]**(0.5)


average_error = sum(error)/len(error)

error_sort = sorted(error)
average_95error = sum(error_sort[100:3871])/len(error_sort[100:3871])

print(average_error)
print(average_95error)

less_1 = 0
less_05 = 0
for i in range(len(error)):
    if error[i]<1:
       less_1 += 1
for i in range(len(error)):
    if error[i]<0.5:
       less_05 += 1
print(less_05/len(error))
print(less_1/len(error))

i = 5
print(result["real_positions"][i])
print(new_cal_positions[i])

diffrent_height_error = [[]]*11
for i in range(11):
    diffrent_height_error[i] = error[361*i:361+361*i]
for i in range(len(diffrent_height_error)):
    diffrent_height_error[i] = sorted(diffrent_height_error[i])

p1 = [0]*11
for i in range(len(p1)):
    p1[i] = i
print(p1)

diffrent_height_average_error = [0]*len(diffrent_height_error)
diffrent_height_95_error = [0]*len(diffrent_height_error)
diffrent_height_80_error = [0]*len(diffrent_height_error)
for i in range(len(diffrent_height_error)):
    diffrent_height_average_error[i] = sum(diffrent_height_error[i])/361
for i in range(len(diffrent_height_error)):
    diffrent_height_95_error[i] = sum(diffrent_height_error[i][10:351])/len(diffrent_height_error[i][10:351])
print(diffrent_height_average_error)
print(diffrent_height_95_error)

plt.figure("Draw")
plt.plot(p1,diffrent_height_error_wo_z )
plt.draw

plt.figure("Draw")
plt.plot(p1,diffrent_x_error_wo_z )
plt.draw

##plot error - z for anchor on 10m 高
plt.figure("Draw")
plt.plot(p1,diffrent_height_average_error)
plt.draw

plt.figure("Draw")
plt.plot(p1,diffrent_height_95_error)
plt.draw
print(sum(diffrent_height_95_error)/len(diffrent_height_95_error))

plt.figure("Draw")
plt.plot(p1,diffrent_height_80_error)
plt.draw

color = [0]*size
for i in range(size):
        if error[i]<noise_scale:
            color[i]="blue"
        elif error[i]>noise_scale and error[i]<5*noise_scale:
            color[i]="green"
        elif error[i]>3*noise_scale and error[i]<10*noise_scale:
            color[i]="yellow"
        elif error[i]>10*noise_scale and error[i]<50*noise_scale:
            color[i]="orange"
        elif error[i]>50*noise_scale:
            color[i]="red"

average_error = 0
psudo_error = 0
for i in range(len(error)):
    average_error += abs(error[i])/(len(error))
    psudo_error += (abs(result["error_x"][i])**2+abs(result["error_y"][i])**2)**0.5/(len(error))
print(average_error)
print(psudo_error)

i =721
real_position = result["real_positions"][i]
calculate_position = result["calculate_positions"][i]
distances = calculate_distances(anchor,anchor_num,real_position)      
E = calculate_distances_diffrences(distances,anchor_num)
A = anchor_num*[0]
B = anchor_num*[0]
C = anchor_num*[0]
D = anchor_num*[0]
for j in range(len(A)):
    A[j] = (anchor[j][0]-calculate_position[0])**2+(anchor[j][1]-calculate_position[1])**2
    B[j] = (anchor[0][0]-calculate_position[0])**2+(anchor[0][1]-calculate_position[1])**2
    C[j] = anchor[j][2]
    D[j] = anchor[0][2]
cost = lambda z: abs(E[4]-((A[4]+(C[4]-z)**2)**0.5)+((B[4]+(D[4]-z)**2)**0.5)) + abs(E[1]-((A[1]+(C[1]-z)**2)**0.5)+((B[1]+(D[1]-z)**2)**0.5)) + abs(E[2]-((A[2]+(C[2]-z)**2)**0.5)+((B[2]+(D[2]-z)**2)**0.5))+abs(E[3]-((A[3]+(C[3]-z)**2)**0.5)+((B[3]+(D[3]-z)**2)**0.5))
ranges = (slice(0, 10, 0.05), )
resbrute = optimize.brute(cost, ranges, full_output = True, finish = None)
new_cal_position = [calculate_position[0],calculate_position[1],float(resbrute[0])]
print(calculate_position)
print(real_position)
print(new_cal_position)